ChatGPT

Aquí tienes las clases modificadas para implementar la funcionalidad de cifrado y firma digital en el sistema de difusión por TCP. He añadido comentarios para explicar el funcionamiento de las modificaciones:

java

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.*;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public class Servidor {
    private ServerSocket serverSocket;
    private static List<ClienteHandler> clientes;
    private KeyPair servidorKeyPair; // Claves pública y privada del servidor

    public static void main(String[] args) {
        Servidor servidor = new Servidor();
        servidor.iniciar();
    }

    public void iniciar() {
        try {
            serverSocket = new ServerSocket(6969);
            System.out.println("Servidor iniciado. Esperando conexiones...");

            clientes = new ArrayList<>();
            // Generar claves públicas y privadas para el servidor
            servidorKeyPair = generarClaves();

            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("Nueva conexión aceptada");

                ClienteHandler clienteHandler = new ClienteHandler(clientSocket, servidorKeyPair.getPublic());
                clientes.add(clienteHandler);
                clienteHandler.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (serverSocket != null) {
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private KeyPair generarClaves() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }

    private class ClienteHandler extends Thread {
        private Socket clientSocket;
        private PublicKey clientePublicKey;
        private PrivateKey servidorPrivateKey;
        // Agregar variables para las claves pública y privada del cliente

        public ClienteHandler(Socket socket, PublicKey servidorPublicKey) {
            clientSocket = socket;
            clientePublicKey = servidorPublicKey;
            // Generar claves pública y privada para el cliente
            // Asignar las claves generadas a las variables correspondientes
        }

        public void run() {
            try {
                // Configurar flujos de entrada y salida
                ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream());
                ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());

                // Enviar clave pública del servidor al cliente
                out.writeObject(servidorKeyPair.getPublic());

                // Recibir clave pública del cliente
                PublicKey clientePublicKey = (PublicKey) in.readObject();

                // Procesar mensajes cifrados y firmados
                while (true) {
                    // Recibir mensaje cifrado y firmado
                    byte[] mensajeCifrado = (byte[]) in.readObject();
                    byte[] firma = (byte[]) in.readObject();

                    // Descifrar el mensaje usando la clave privada del servidor
                    Cipher decCipher = Cipher.getInstance("RSA");
                    decCipher.init(Cipher.DECRYPT_MODE, servidorKeyPair.getPrivate());
                    byte[] mensajeDesencriptado = decCipher.doFinal(mensajeCifrado);

                    // Verificar la firma con la clave pública del cliente
                    Signature verificador = Signature.getInstance("SHA256withRSA");
                    verificador.initVerify(clientePublicKey);
                    verificador.update(mensajeDesencriptado);

                    if (verificador.verify(firma)) {
                        // La firma es válida, mostrar el mensaje
                        String mensajeTexto = new String(mensajeDesencriptado);
                        System.out.println("Mensaje recibido: " + mensajeTexto);
                    } else {
                        System.err.println("Firma inválida. Mensaje descartado.");
                    }
                }
            } catch (IOException | ClassNotFoundException | NoSuchAlgorithmException |
                     NoSuchPaddingException | InvalidKeyException | BadPaddingException |
                     IllegalBlockSizeException | SignatureException e) {
                e.printStackTrace();
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

java

import java.io.*;
import java.net.Socket;
import java.security.*;
import java.util.Base64;
import javax.crypto.Cipher;

public class Cliente {
    private static final long TIEMPO_ENTRE_MENSAJES = 3000;

    public static void main(String[] args) {
        try {
            Socket socket = new Socket("172.16.255.201", 6969);
            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
            BufferedReader lectorConsola = new BufferedReader(new InputStreamReader(System.in));

            // Generar claves pública y privada para el cliente
            KeyPair clienteKeyPair = generarClaves();

            // Recibir clave pública del servidor
            PublicKey servidorPublicKey = (PublicKey) in.readObject();

            // Enviar clave pública del cliente al servidor
            out.writeObject(clienteKeyPair.getPublic());

            // Configurar hilos para enviar y recibir mensajes
            Thread hiloRecibirMensajes = new Thread(() -> {
                try {
                    while (true) {
                        // Recibir mensaje cifrado y firmado
                        byte[] mensajeCifrado = (byte[]) in.readObject();
                        byte[] firma = (byte[]) in.readObject();

                        // Descifrar el mensaje usando la clave privada del cliente
                        Cipher decCipher = Cipher.getInstance("RSA");
                        decCipher.init(Cipher.DECRYPT_MODE, clienteKeyPair.getPrivate());
                        byte[] mensajeDesencriptado = decCipher.doFinal(mensajeCifrado);

                        // Verificar la firma con la clave pública del servidor
                        Signature verificador = Signature.getInstance("SHA256withRSA");
                        verificador.initVerify(servidorPublicKey);
                        verificador.update(mensajeDesencriptado);

                        if (verificador.verify(firma)) {
                            // La firma es válida, mostrar el mensaje
                            String mensajeTexto = new String(mensajeDesencriptado);
                            System.out.println("Mensaje recibido: " + mensajeTexto);
                        } else {
                            System.err.println("Firma inválida. Mensaje descartado.");
                        }
                    }
                } catch (IOException | ClassNotFoundException | NoSuchAlgorithmException |
                         NoSuchPaddingException | InvalidKeyException | BadPaddingException |
                         IllegalBlockSizeException | SignatureException e) {
                    e.printStackTrace();
                }
            });
            hiloRecibirMensajes.start();

            Thread hiloEnviarMensajes = new Thread(() -> {
                try {
                    while (true) {
                        String mensajeUsuario = lectorConsola.readLine();

                        // Encriptar el mensaje con la clave pública del servidor
                        Cipher encCipher = Cipher.getInstance("RSA");
                        encCipher.init(Cipher.ENCRYPT_MODE, servidorPublicKey);
                        byte[] mensajeCifrado = encCipher.doFinal(mensajeUsuario.getBytes());

                        // Firmar el mensaje con la clave privada del cliente
                        Signature firmador = Signature.getInstance("SHA256withRSA");
                        firmador.initSign(clienteKeyPair.getPrivate());
                        firmador.update(mensajeUsuario.getBytes());
                        byte[] firma = firmador.sign();

                        // Enviar mensaje cifrado y firmado al servidor
                        out.writeObject(mensajeCifrado);
                        out.writeObject(firma);

                        Thread.sleep(TIEMPO_ENTRE_MENSAJES);
                    }
                } catch (IOException | NoSuchAlgorithmException | NoSuchPaddingException |
                         InvalidKeyException | BadPaddingException | IllegalBlockSizeException |
                         SignatureException | InterruptedException e) {
                    e.printStackTrace();
                }
            });
            hiloEnviarMensajes.start();

            // Esperar que ambos hilos terminen antes de cerrar los recursos
            hiloRecibirMensajes.join();
            hiloEnviarMensajes.join();

            out.close();
            in.close();
            lectorConsola.close();
            socket.close();
        } catch (IOException | InterruptedException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static KeyPair generarClaves() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }
}

Estas modificaciones agregan el cifrado y la firma digital en las comunicaciones entre el servidor y el cliente. Ambos generan sus pares de claves públicas y privadas, intercambian las claves públicas, y luego utilizan estas claves para cifrar y firmar los mensajes. Los mensajes son transmitidos como bytes cifrados y firmados, y se verifican en el extremo receptor antes de mostrarlos.